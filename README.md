# <h1 align="center">Cartesian Graph Builder (CGB)<br>Построитель элементарных графиков в прямоугольной системе координат</h1>
---
## Краткое описание

Приложение предназначено для быстрого построения графиков некоторых элементарных функций с возможностью измененения масштаба системы координат. Целевая ОС: <b>Windows 10</b>.

## Возможности

Приложение поддерживает:
- степенные функции (вида y = a * (x - b) ^ n + c, соответственно, в том числе y = a / (x + b) ^ n + c)
- показательные и логарифмические функции (вида y = a ^ x и y = e ^ x);
- различные комбинации вышеприведенных;
- изменение масштаба координатной плоскости (в фиксированном диапазоне).

## Ограничения

Не реализовано:
- тригонометрические функции (sin, cos, tan и т.д.);
- гиперболические и обратные гиперболические функции (ch, sh и т.д.);
- константы и математические функции;
- другие системы координат;
- произвольное центрирование системы координат;
- одновременное отображение нескольких функций.

## Развертывание

Приложение разработано в IDE <b>Microsoft Visual Studio 2022</b> на C++ с использованиям <b>Windows Forms (CLI)</b>. Стандарт языка - <b>C++17</b>.
В репозитории находятся только исходники. Для компиляции и сборки исполняемого файла необходимо скачать два проекта (<i>Calculator</i> и <i>GUI_Application</i>), запустить в проекте <i>GUI_Calculator</i> файл <i>GUI_Application.sln</i>.
Соответственно, в открывшемся окне Microsoft Visual Studio скомпилировать и собрать приложение. В дальнейшем полученный исполняемый файл можно переносить и использовать в любом месте.

## Примеры работы приложения

![Пример 1. y=3*(x-2)^4+1](/img/example1.png)
![Пример 2. y=16/(x+1)^2+4](/img/example2.png)
![Пример 3. y=e^x](/img/example3.png)
![Пример 4. y=-16/(x+1)^2+4](/img/example4.png)

## Об архитектуре приложения

### Общий алгоритм работы

Фактически задача построения графика - это вычисления пар {<i>X</i>, <i>Y</i>} (точек) и их соединение на конкретном отрезке, где <i>Y</i> определяется через независимую переменную <i>X</i>.

Исходя из этого, построение графика функции можно разбить на два основных этапа:<br>
1. Вычисление значений {<i>X</i>, <i>Y</i>}
2. Последовательное соединение полученных точек

Таким образом, точность графика зависит от шага изменения <i>X</i> (<i>n =< X =< m</i>, где <i>n</i> - минимальное целое значение <i>X</i> на оси абсцисс, а <i>m</i> - максимальное целое значение).
Алгоритм построения графика следующий:<br>
1. Инициализировать <i>X1</i> и <i>delta</i> (шаг изменения <i>X</i>)
2. Вычислить <i>Y1 = f(X1)</i>
3. Изменить <i>X2 = X1 + delta</i>
4. Вычислить <i>Y2 = f(X2)</i>
5. Построить линию с началом в точке {<i>X1</i>, <i>Y1</i>} и конечной точкой {<i>X2</i>, <i>Y2</i>}
6. Если <i>X2 < m</i>, то <i>X1 = X2</i>, перейти к шагу 2; иначе закончить построение

Разумеется, помимо этого необходимо, как минимум, предусмотреть обработку разрыва и выхода значений <i>Y</i> за пределы координатной системы. 
Однако это можно считать за детали реализации алгоритма.

Функция вычисляется элементарно: вместо <i>X</i> подставляется конкретное значение, что превращает функцию в обычное арифметическое выражение.
Полученное выражение вычисляется с помощью обратной польской нотации. Этот результат и есть значение <i>Y</i>.

### Концептуальное описание приложения

Приложение разбито на 3 слабозависимых (могут использоваться отдельно друг от друга с небольшими изменениями) слоя:
- модель (Model)
- представление, форма (View)
- контроллер (Controller)

Модель делится на два модуля: преобразователь арифметического выражения из инфиксной записи в постфиксную (обратную польскую нотацию) и вычислитель арифметического выражения, записанного в постфиксной нотации.

Представление - это элементы Windows Forms, использующиеся для вывода графика, ввода функции и управления масштабом.

Слой контроллера заключается в валидаторе введенной функции, где осуществляется проверка правильности комбинаций операторов, баланс скобок и корректность использования символа константы e и аргумента X.

Схема обращений слоев (вызовы функций) следующая: View => Controller => Model

### Концептуальные схемы приложения

![Схема 1. Диаграмма состояний приложения](/img/scheme1_states.png)
<p align="center">Диаграмма состояний приложения</p>
<br>

![Схема 2. Диаграмма кооперации слоев приложения на примере задачи построения графика](/img/scheme2_cooperation.png)
<p align="center">Диаграмма кооперации слоев приложения на примере задачи построения графика</p>
<br>

![Схема 3. Диаграмма компонентов приложения](/img/scheme3_components.png)
<p align="center">Диаграмма компонентов приложения</p>
<br>

![Схема 4. Диаграмма классов слоя "модель"](/img/scheme4_classes_model.png)
<p align="center">Диаграмма классов слоя "модель"</p>
<br>

![Схема 5. Диаграмма классов слоя "представление"](/img/scheme5_classes_view.png)
<p align="center">Диаграмма классов слоя "представление"</p>
<br>

![Схема 6. Диаграмма классов слоя "контроллер"](/img/scheme6_classes_controller.png)
<p align="center">Диаграмма классов слоя "контроллер"</p>
<br>

![Схема 7. Диаграмма последовательности на примере построения графика](/img/scheme7_sequence.png)
<p align="center">Диаграмма последовательности на примере построения графика</p>
<br>

### Особенности программной реализации

Все объекты определены в пространствах имен. Всего выделено три основных пространств имен:
1. `GUIApplication` – содержит слой «Представление» и слой «Контроллер». Сюда относятся все сущности, которые работают с графикой или сильно связаны с программным окружением
2. `MathExpression` – содержит объявление доступных нотаций и математических операторов, информацию о них (ассоциативность). Является частью слоя «Модель»
3. `MathExprCalculator` – содержит классы конвертер, исполнитель и калькулятор. Здесь реализована основная логика модели. Является частью слоя «Модель»

Краткое описание классов:
- `MathExpression::Notation` – перечисление с двумя значениями: `MathExpression::Notation::RPN` и `MathExpression::Notation::AST`. Нужно для определения типа конвертера и исполнителя в шаблонах
- `MathExpression::Operator` – перечисление, в котором даются имена всем доступным для калькулятора математическим операторам
- `MathExpression::Associativity` – перечисление с двумя значениями: `MathExpression::Associativity::left` и `MathExpression::Associativity::right`. Нужно для последующего сопоставления операторов и их ассоциативности
- `template<MathExpression::Notation> MathExpression::IExprConverveter` – интерфейс конвертера
- `template<MathExpression::Notation> MathExpression::IExprExecuter` – интерфейс исполнителя
- `MathExprCalculator::ICalculator` – интерфейс калькулятора
- `MathExprCalculator::ConverterRPN : public MathExpression::IExprConverter<MathExpression::Notation::RPN>` – конвертер математического выражения, использующий обратную польскую нотацию
- `MathExprCalculator:: ExecuterRPN : public MathExpression::IExprExecuter<MathExpression::Notation::RPN>` – исполнитель математических выражений в обратной польской нотации
- `template<MathExpression::Notation N> Calculator : public ICalculator` – калькулятор математических выражений
- `template<char argument = 'x'> GUIApplication::PreCalculator` – прекалькулятор, выполняет подстановку вместо аргумента и констант конкретных значений
- `GUIApplication::Validater` – валидатор, проверяет входную формулу на корректность
- `GUIApplication::CartesianSystem` – прямоугольная система координат. Служит связующим звеном между холстом и графиком. Также содержит метод для отрисовки системы координат
- `GUIApplication::CartesianSystem::Plot` – график, служит для отрисовки графика на холсте
- `GUIApplication::MainForm : public System::Windows::Forms::Form` – форма, агрегирует все элементы управления, в том числе холст

### Разбиение приложения на проекты

В репозитории находятся два проекта:
- `Calculator`
- `GUI_Application`

Первый содержит логику приложения без интерфейса. То есть в нем реализован слой "модель". 
Взаимодействие с компонентами возможно посредством консоли.

Второй же проект включает в себя все, что относится к графическому интерфейсу, иными словами в нем реализованы слои "представление" и "контроллер". 
При этом с помощью относительных ссылок он импортирует нужные исходники из первого проекта.
Поэтому <b>необходимо, чтобы при компиляции приложения оба проекта находились на одном уровне в файловой системе</b>.

Можно слить все файлы обоих проектов в один. Единственное, что нужно будет изменить - это пути в директивах `#include`.

